# Language analyzer with flex, bison and symtab

## Index
1. [Introduction](#introduction)
2. [Code structure](#code-structure)
3. [Explanation](#explanation)
4. [Usage](#usage)

## Introduction
This project implements the analyzer of a calculator language using flex, bison and symtab. 
The language is able to do the following operations:
    - Define variables
    - Assign values to variables
    - Do arithmetic operations
    - Print the value of a variable (via expressions)
    - Print the value of an expression

And other operations like:
    - Do boolean operations
    - String concatenation with any value
    - Functions: substr, len and trigonometric functions (sin, cos, tan)
    - Unary operators: +, -, not
    - Parentheses to change the order of operations
    - Comments with // or /* */ or #
    - Arithmetic comparison operators: <, >, <=, >=, ==, !=
    - Constants: pi, e (this names can't be used as variables)

## Code structure
The project is divided in the following folders:
    - bin: contains the executable file (generated by the makefile)
    - build: contains the generated files from flex and bison (generated by the makefile)
    - include: contains the header files
    - src: contains the source files

In the bin folder, you can find the executable file.
    - compiler: the executable file

In the build folder, you can find the following files:
    - lex.yy.c: the C code generated by flex
    - parser.tab.c: the C code generated by bison
    - parser.tab.h: the header file generated by bison
    - parser.output: the output of bison (it contains the states of the parser and the conflicts)

In the include folder, you can find the following files:
    - data.h: contains the definitions of the data structures
    - symtab.h: contains the definitions of the functions to manage the symbol table
    - functions.h: contains the definitions of the functions needed to execute the main

In the src folder, you can find the following files:
    - main.c: contains the main function
    - data.c: contains the functions to manage the data structures
    - symtab.c: contains the functions to manage the symbol table
    - functions.c: contains the functions needed to execute the main (it also contains the implementations for string concatenation and substring.)


## Explanation
The compiler is able to do all that was requested in the project.

The operations precedence is implemented using the grammar definition.
The data types are defined in the data.h file and implemented in the data.c file. The data types are:
    - int: integer values
    - float: floating point values
    - string: string values
    - bool: boolean values
    - unknown: used to define the type of a variable that hasn't been assigned yet

The exchange of information between the lexer and the parser is done using the yylval variable. The lexer returns the value of the token in this variable, and the parser uses it to store the value of the token in the data structure. To do so, I defined the union YYSTYPE in the parser.y file. This union contains the data structure that will store the value of the token. It contains the following fields:
    - integer: to store integer values
    - real: to store floating point values
    - string: to store string values
    - boolean: to store boolean values
    - no_value: to store the value of a variable that hasn't been assigned yet
I defined the type of each token in the bison file, so when that token is found, the lexer will return the value of the token in the correct field of the YYSTYPE union.

To be able to do the semantic analysis, I defined the types of each expression that is basically: ident.id_val, that is of the type value_info, the data structure contained in data.c that lets us store the information related to a variable (data_type and value).

Each time an expression gets evaluated, it returns to the upper level its value and type using the semantic actions.

The string concatenation, arithmetic operations and boolean operations are implemented with the same root parent expression, to be able to do the operations with the correct precedence without conflicts. Each expression is evaluated in the semantic actions using conditional statements to check the type of the expression and do the correct operation. For example, when we encounter an expression like this:
    - expr_arithmetic PLUS expr_unary
we check if the types of each operand are numeric values, if so, we perform an arithmetic operation (performing the needed castings). If one of the operands is a string, we perform the concatenation operation (implemented in src/functions.c) casting the other value to string using the function value_to_str implemented in src/data.c. If the operands are boolean or unknown, we return an error.
And so for the other operations, we always check the types of the operands to do the correct operation, in case of trying to do an operation with unallowed types, we call the yyerror function (implemented in src/functions.c) to print an error message and stop the execution.

## Usage
I prepared a Makefile to compile the project. This makefile will create the needed folders and generate the C code from the flex and bison files, that will be compiled and linked to create the executable file. 

To compile the project, you just need to run the following command:
```bash
make
```
To remove the generated files, you can run:
```bash
make clean
```

I also prepared a script to test the program with some examples. You can run it with the following command:
```bash
./execution_script.sh
```
If you execute this script, you do not have to worry about the compilation (using the previous commands) and generation of the output files, this is all done by the script itself.

You cand find the examples in example_files/input_files. The script will generate two additional folders: example_files/output_files and example_files/stdout_files. The first one will contain each syntactic production of the input files, and the second one will contain the output of the program for each input file.
